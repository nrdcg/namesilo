package gen

import (
	"bytes"
	"go/format"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"testing"
	"text/template"

	"github.com/stretchr/testify/require"
)

func TestGenerateClientMethods(t *testing.T) {
	t.Skip("generator")

	clientMethodsTemplate := `// Code generated by gen/gen_test.go DO NOT EDIT.

package namesilo

import (
	"context"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
)
{{range $key, $value := .Names }}
// {{ $value.Upper }} Execute operation {{ $value.Lower }}.
func (c *Client) {{ $value.Upper }}(ctx context.Context, params *{{ $value.Upper }}Params) (*{{ $value.Upper }}, error) {
	resp, err := c.get(ctx, "{{ $value.Lower }}", params)
	if err != nil {
		return nil, err
	}

	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("error: HTTP status code %v", resp.StatusCode)
	}

	bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	op := &{{ $value.Upper }}{}

	err = xml.Unmarshal(bytes, op)
	if err != nil {
		return nil, fmt.Errorf("failed to decode: %w: %s", err, bytes)
	}

	switch op.Reply.Code {
	case SuccessfulAPIOperation:
		// Successful API operation
		return op, nil
	case SuccessfulRegistration:
		// Successful registration, but not all provided hosts were valid resulting in our nameservers being used
		return op, nil
	case SuccessfulOrder:
		// Successful order, but there was an error with the contact information provided so your account default contact profile was used
		return op, nil
	default:
		// error
		return op, fmt.Errorf("code: %s, details: %s", op.Reply.Code, op.Reply.Detail)
	}
}
{{end}}
`

	err := generate(clientMethodsTemplate, "zz_gen_client.go")
	require.NoError(t, err)
}

func TestGenerateClientTest(t *testing.T) {
	t.Skip("generator - several exception")

	clientTestsTemplate := `// Code generated by gen/gen_test.go DO NOT EDIT.

package namesilo

import (
	"context"
	"encoding/xml"
	"io"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func setupFakeAPI(t *testing.T, dir, operation string) *Client {
	t.Helper()

	mux := http.NewServeMux()
	server := httptest.NewServer(mux)
	t.Cleanup(server.Close)

	mux.HandleFunc("/"+operation, func(w http.ResponseWriter, r *http.Request) {
		query := r.URL.Query()

		key := query.Get("key")
		if key != "1234" {
			err := xml.NewEncoder(w).Encode(Operation{Reply: Reply{Code: "110", Detail: "Invalid API Key"}})
			if err != nil {
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}
		}

		f, err := os.Open(filepath.Clean(filepath.Join(".", "samples", dir, operation+".xml")))
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}

		_, err = io.Copy(w, f)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
	})

	transport, err := NewTokenTransport("1234")
	require.NoError(t, err)

	client := NewClient(transport.Client())
	client.Endpoint = server.URL

	return client
}
{{range $key, $value := .Names }}
func TestClient_{{ $value.Upper }}(t *testing.T) {
	client := setupFakeAPI(t, "{{ $value.Dir }}", "{{ $value.Lower }}")

	params := &{{ $value.Upper }}Params{}

	result, err := client.{{ $value.Upper }}(context.TODO(), params)
	require.NoError(t, err)

	require.NotNil(t, result)

	assert.IsType(t, &{{ $value.Upper }}{}, result)
}
{{end}}
`

	err := generate(clientTestsTemplate, "zz_gen_client_test.go")
	require.NoError(t, err)
}

func TestGenerateModelTest(t *testing.T) {
	t.Skip("generator")

	modelTestsTemplate := `// Code generated by gen/gen_test.go DO NOT EDIT.

package namesilo

import (
	"bytes"
	"encoding/xml"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/stretchr/testify/require"
)

func assertXMLEqual(t *testing.T, model any, fixture string) {
	t.Helper()

	expected, err := os.ReadFile(filepath.FromSlash(fixture))
	require.NoError(t, err)

	err = xml.Unmarshal(expected, model)
	require.NoError(t, err)

	raw, err := xml.MarshalIndent(model, "", "    ")
	require.NoError(t, err)

	// Fix self-closing tags.
	exp, err := regexp.Compile("<(\\w+)></\\w+>")
	require.NoError(t, err)

	raw = exp.ReplaceAll(raw, []byte("<$1/>"))

	if toCleanString(raw) != toCleanString(expected) {
		t.Logf("Got:\n%s\n\nWant:\n%s\n", string(raw), string(expected))
		t.Error("Errors")
	}
}

func toCleanString(data []byte) string {
	return strings.TrimSuffix(strings.ReplaceAll(string(data), "\r\n", "\n"), "\n")
}

{{range $key, $value := .Names }}
func Test{{ $value.Upper }}(t *testing.T) {
	assertXMLEqual(t,  &{{ $value.Upper }}{}, "./samples/{{ $value.Dir }}/{{ $value.Lower }}.xml")
}
{{end}}
`

	err := generate(modelTestsTemplate, "model_test.go")
	require.NoError(t, err)
}

func TestGenerateBaseParams(t *testing.T) {
	t.Skip("generator - only to initiate the structures")

	paramsTemplate := `package namesilo
{{range $key, $value := .Names }}
// {{ $value.Upper }}Params Parameters for operation {{ $value.Lower }}.
type {{ $value.Upper }}Params struct {
	// TODO
}
{{end}}
`

	err := generate(paramsTemplate, "zz_gen_params.go")
	require.NoError(t, err)
}

func generate(tmpl, filename string) error {
	type BaseName struct {
		Lower string
		Upper string
		Dir   string
	}

	var baseNames []BaseName

	err := filepath.WalkDir(filepath.FromSlash("../samples"), func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if d.IsDir() {
			return nil
		}

		if d.Name() == "OPERATION.xml" {
			return nil
		}

		if strings.Contains(d.Name(), "-") {
			return nil
		}

		if strings.Contains(d.Name(), "_") {
			return nil
		}

		baseName := strings.TrimSuffix(d.Name(), filepath.Ext(d.Name()))
		baseNames = append(baseNames, BaseName{
			Lower: baseName,
			Upper: strings.ToUpper(string(baseName[0])) + baseName[1:],
			Dir:   filepath.Base(filepath.Dir(path)),
		})

		return nil
	})
	if err != nil {
		return err
	}

	slices.SortFunc(baseNames, func(a, b BaseName) int {
		return strings.Compare(a.Lower, b.Lower)
	})

	data := map[string]any{
		"Names": baseNames,
	}

	base := template.New(filename)

	parse, err := base.Parse(tmpl)
	if err != nil {
		return err
	}

	b := &bytes.Buffer{}

	err = parse.Execute(b, data)
	if err != nil {
		return err
	}

	// gofmt
	source, err := format.Source(b.Bytes())
	if err != nil {
		return err
	}

	return os.WriteFile(filepath.Join("..", filename), source, 0o666)
}
